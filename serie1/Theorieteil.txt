RA Serie 1
----------
Thomas Rickenback
Mathieu Simon 07-121-650


Theorieteil
-----------

Aufgabe 1
---------
1) Wie lang (in Bytes) ist der String “Test”?
Gemäss Folie 19 aus dem C-Skript: 
Ist ein Array aus "char", "Strings sind nullterminiert, der Letzte Wert ist 0"

Daraus folgt:
T e s t \0 -> Länge = 5 Bytes


2)
Falls die Frage gestellt wäre, dass mittels shorts oder ints
ein double-Array abgebildet werden müsste, wäre das hier natürlich nicht 
korrekt.

Mit einem Int-Array (zu ohne Pointerarithmetik)

int a[10];			short a[10];

int getAt(int i){		short getAt(short i){
  return a[i];				return a[i];
}				}

Der Unteschied hier liegt im Speicherverbauch zwischen int, short und double:
double x 10 --> 8 Bytes pro Element	   = 80 Bytes
int    x 10 --> 2 oder 4 Bytes pro Element = 20 oder 40 Bytes
short  x 10 --> 2 Bytes pro Element        = 20 Bytes


Gleiches Resultat mit Pointerarithmetik

int getAt(int *a, int i) {
	return *(a+i);
}


short a[10];

short getAt(int i) {
 	return a[i];
}

Gleiches Resultat mit Pointerarithmetik
short getAt(short *a, int i) {
 	return *(a+i);
}

Mit der Array-Deklaration wird der erforderliche Speicherplatz reserviert. 
Bei short-Arrays sind dies 2 Bytes, bei int-Arrays 2 oder 4 Bytes pro 
Datenelement. Dadurch kann auch hier mit der Pointerarithmetik der 
entsprechende Wert aufgefunden werden, wie dies auch im Beispiel mit dem 
double-Array, wo die Elemente 8 Bytes lang sind, der Fall war.

3)



	1.
1. Zeile:

void = typenloser Zeiger
-> p zeigt auf die Speicheradresse von b und ist selber typenlose

2. Zeile
Die Speicheradresse von

Adresse von b (&) wird an p übergeben, dass einen Variablen Typ sein kann (void *p)

2. 
Gibr den Hexadezimalwert dieser Adresse (von p) aus:
bff61c

3.


Wird der Cast und dereferenzierung weggelassen wird nochmals die
gleiche Adresse angezeit - erst nachher die Inkrementierung 
der Speicheradresse von P
von p.




Aufgabe 4
---------
j = increment(&i) -> j wird die Rückgabe von increment erhalten

increment(int *x)
-> Es wird ein x übergeben, dass dann auch
   auf Zeile 8 dereferenziert wird.

Reihenfolge auf Zeile 8
 i wird dereferenziert, also 1337
 ++ steht vor der Klammer, also wird inkrementiert und dann zurückgegeben
 Rückgabewert ist somit: 1338 - i wird überschriebem - bzw. zeigt immer noch auf dieselbe Adresse.

Bei *:
Es wird ein Post-Increment gemacht, d.h. es wird zuerst die Rückgabe gemacht, dann
inkrementiert. i=1337, j=1337

zeigt auf die Adresse von i


Aufgabe 5
---------
Ausgabe:
1 1
1 2

Zeile 1 *x -> Erster Wert im array x wird dereferenziert, und bei *px auch

Zeile 5: px++ hat den zeiger inkrementiert bei px und zeigt nun auf den zweiten Wert im Array, also 2


---

Ausgabe bei zweitem Beispiel: 3, 11

Problematisch:
*(px--) überschreibt den Wert vor dem ersten Wert im Array x  - also Speicherbereich 
etwa eines anderen Programmes.

Aufgabe 5
---------

1 short x[3] = {1, 2, 3};
2 short *px = x;
3 printf("%i %i\n", *x, *px);
4 px++;
5 printf("%i %i\n", *x, *px);




u
o
Probleme auftreten k ̈nnen:
o
1
2
3
4
5
short x = 3;
short *px = &x;
*(px--) = 10;
*px = 11;
printf("%i %i\n", x, *px);



Aufgabe 6
----------
struct {
	char a[4];	-> 4 Bytes benötigt
	char b;		-> 1 Byte  ""
	char c;		-> 1 Byte  "" 
	short int d;	-> 2 Bytes (eines davon das Vorzeichen)
} myStruct;
                           = 8 Bytes Total, einfach addiert

union {
	char a[8];	-> 8 Bytes 
	int b;		-> 1 Byte
	short int d[4]; -> 8 Bytes (je 2 Bytes pro Int x 4)
} myUnion;
			   = Da es eine Union ist, verwendez sie
			     denselben Speicherbereich. (des längsten
			     "Elementes"), also 8 Bytes.

printf("%i", sizeof(myStruct));
printf("%i", sizeof(myUnion));


Bei der Union zeigen alle Elemente auf dieselbe Startadresse, bei der Struct
zeigt jedes Element auf eine eigene. - Richtig?

Aufgabe 7
---------

 1 #define callA callB(1)
 2 
 3 void callB(int a) {
 4	printf("%i\n", a+2);
 5 }
 6 
 7 int main() {
 8 	callA;
 9 	return EXIT_SUCCESS;
10 }


1 -> Präprozessoranweisung, ersetzt alle Vorkommnisse im Quellcode
     von callA durch den Aufruf von callB(1). Kann Code abkürzen, oft
     verwendet um Konstanten zu definieren.

9 -> Effektiv steht callB(1), die Funktion callB wird mit dem Parameter
     a=1 aufgerufen, dann ausgabe von in Zeile 4

4 -> Als Integer (%i) formatiert, abgeschlossen von einer neuen Zeile:
     a + 2 -> 1 + 2 -> "3" wird ausgegeben.
